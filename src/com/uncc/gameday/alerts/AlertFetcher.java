package com.uncc.gameday.alerts;

import java.util.Iterator;
import java.util.List;

import twitter4j.Paging;
import twitter4j.Status;
import twitter4j.Twitter;
import twitter4j.TwitterException;
import twitter4j.TwitterFactory;
import android.content.Context;
import android.content.SharedPreferences;
import android.widget.Toast;

import com.uncc.gameday.R;

public class AlertFetcher {
	// Class responsible for fetching all alerts as necessary.
	
	private int maxTweets = 5;
	
	public void fetchAlerts(Context ctx) {
		// Fetch all alerts. Responsible for discovering what sources need to be fetched.
		
		// Note we have to use the SharedPreferences so that we have preferences no matter what activity
		// sent us this context
		SharedPreferences settings = ctx.getSharedPreferences(ctx.getString(R.string.preferences_file), 0); // MODE_PRIVATE
		
		if (settings.getBoolean("ALERT_TIMED", false))
			// Fetch timed alerts
			this.fetchTimedAlerts(ctx);
		else if (settings.getBoolean("ALERT_ORGANIZATION", false))
			// Fetch organization alerts
			this.fetchOrganizationAlerts(ctx);
		else if (settings.getBoolean("ALERT_UNIVERSITY", false))
			// Fetch university alerts
			this.fetchUniversityAlerts(ctx);
		
		// And always fetch alerts made by us. Period.
		this.fetchGamedayAlerts(ctx);
	}
	
	private void fetchTimedAlerts(Context ctx) {
		// Process the rules for all timed alerts.
	}
	
	private void fetchOrganizationAlerts(Context ctx) {
		// Process fetching organization alerts (alerts retweeted by us)
		int duration = Toast.LENGTH_SHORT;
		
		try {
			String handle = ctx.getString(R.string.gameday_handle);
			Twitter twitter = TwitterFactory.getSingleton();
			List<Status> statuses = twitter.getUserTimeline(handle, new Paging(1, maxTweets));
			
			// Filter for anything created by us (retweet)
			for (Iterator<Status> it = statuses.iterator(); it.hasNext();){
				// May need to switch to isRetweetByMe (documentation is awful)
				if (!it.next().isRetweet())
					it.remove();
			}
			
			// List contains all valid alerts now
			
		} catch (TwitterException e) {
			Toast.makeText(ctx,
					"Unable to fetch alerts for organizations!\nAre you connected to the internet?",
					duration).show();
			e.printStackTrace();
		}
	}
	
	private void fetchUniversityAlerts(Context ctx) {
		// Process fetching university alerts
		int duration = Toast.LENGTH_SHORT;
		
		try {
			String handle = ctx.getString(R.string.university_handle);
			Twitter twitter = TwitterFactory.getSingleton();
			List<Status> statuses = twitter.getUserTimeline(handle, new Paging(1, maxTweets));
			
			// List contains all valid alerts now
			
		} catch (TwitterException e) {
			Toast.makeText(ctx,
					"Unable to fetch alerts for the University!\nAre you connected to the internet?",
					duration).show();
			e.printStackTrace();
		}
	}
	
	private void fetchGamedayAlerts(Context ctx) {
		// Process fetching alerts generated by staff of UNCCGameDay
		int duration = Toast.LENGTH_SHORT;
		
		try {
			String handle = ctx.getString(R.string.gameday_handle);
			Twitter twitter = TwitterFactory.getSingleton();
			List<Status> statuses = twitter.getUserTimeline(handle, new Paging(1, maxTweets));
			
			// Filter out anything not from us
			for (Iterator<Status> it = statuses.iterator(); it.hasNext();){
				// May need to switch to isRetweetByMe (documentation is awful)
				if (it.next().isRetweet())
					it.remove();
			}
			
			// List contains all valid alerts now.
			
		} catch (TwitterException e) {
			Toast.makeText(ctx,
					"Unable to fetch alerts from Gameday!\nAre you connected to the internet?",
					duration).show();
			e.printStackTrace();
		}
	}
}
